#!/usr/bin/env racket --load
;;; Program that converts gui_simulator setups into a format my project can parse

(struct track (id start end length db?) #:mutable #:transparent)
(struct switch (id track-1 track-2) #:mutable #:transparent)

(define tracks (make-hash))
(define switches #f)

(define G62     61.88)
(define G119    119.54)
(define G231    230.93)
(define G239    239.07)
(define R2      (* 421.88 (/ pi 6)))
(define R2-7.5  (* 421.88 (/ pi 24)))
(define R3      (* 483.75 (/ pi 6)))
(define R9      (* 907.97 (/ pi 12)))
(define G62-R2  (+ 61.88 (* 421.88 (/ pi 6))))

(define (gentrack length (id (gensym "T")))
  (let ((track (track id #f #f (if (list? length) (apply + length) length) #f)))
    (hash-set! tracks id track)
    track))

(define (genswitch length-1 length-2 (id (gensym "S")))
  (let ((switch (switch id (gentrack length-1) (gentrack length-2))))
    (hash-set! switches id switch)
    switch))

(define (WR id) (genswitch G239 R9 id))
(define (WL id) (genswitch G239 R9 id))
(define (BWR id) (genswitch R2 G62-R2 id))
(define (BWL id) (genswitch R2 G62-R2 id))
(define (W3 id)
  (let-values (((id-a id-b) (split-triple-switch-id id)))
    (let* ((switch-b (switch id-b (gentrack G239) (gentrack R9)))
           (switch-a (switch id-a (gentrack R9) switch-b)))
      (hash-set! switches id-b switch-b)
      (hash-set! switches id-a switch-a)
      switch-a)))
(define (DKWR id) (genswitch (/ 239.07 2) (* (/ 907.97 2) (/ pi 12)) id))

(define invert identity)

(define (reverse-indeces a-switch)
  (lambda (id)
    (let* ((switch (a-switch id))
           (track-1 (switch-track-1 switch))
           (track-2 (switch-track-2 switch)))
      (set-switch-track-1! switch track-2)
      (set-switch-track-2! switch track-1)
      switch)))

(define (id-exists? id)
  (or (hash-has-key? tracks id)
      (hash-has-key? switches id)))

(define (split-triple-switch-id id)
  (let-values (((s a b) (apply values (string-split (symbol->string id) "-"))))
    (values (string->symbol (string-append s "-" a))
            (string->symbol (string-append s "-" b)))))

(define (start id)
  (cond ((hash-has-key? switches id)
         (let ((switch (hash-ref switches id)))
           (cons (track-start (switch-track-1 switch))
                 (lambda (node)
                   (set-track-start! (switch-track-1 switch) node)
                   (set-track-start! (switch-track-2 switch) node)))))
        ((hash-has-key? tracks id)
         (let ((track (hash-ref tracks id)))
           (cons (track-start track)
                 (lambda (node) (set-track-start! track node)))))
        (else (let-values (((id-a id-b) (split-triple-switch-id id)))
                (let ((switch-a (hash-ref switches id-a))
                      (switch-b (hash-ref switches id-b)))
                  (cons (track-start (switch-track-1 switch-a))
                        (lambda (node)
                          (set-track-start! (switch-track-1 switch-a) node)
                          (set-track-start! (switch-track-1 switch-b) node)
                          (set-track-start! (switch-track-2 switch-b) node))))))))
(define (end id . switch-end)
  (cond ((hash-has-key? switches id)
         (let* ((switch (hash-ref switches id))
                (track (if (= (car switch-end) 0)
                         (switch-track-1 switch)
                         (switch-track-2 switch))))
           (cons (track-end track)
                 (lambda (node)
                   (set-track-end! track node)))))
        ((hash-has-key? tracks id)
         (let ((track (hash-ref tracks id)))
           (cons (track-end track)
                 (lambda (node) (set-track-end! track node)))))
        (else (let-values (((id-a id-b) (split-triple-switch-id id)))
                (let ((switch-a (hash-ref switches id-a))
                      (switch-b (hash-ref switches id-b)))
                  (case (car switch-end)
                    ((0) (end id-a 0))
                    ((1) (end id-b 0))
                    ((2) (end id-b 1))))))))
(define (eval-connect datum)
  (define (eval-datum d)
    (let ((id (cadr d)))
      (eval (list-set d 1 `',id))))
  (let ((track-1 (eval-datum (car datum)))
        (track-2 (eval-datum (cadr datum))))
    (cond ((car track-1)
           ((cdr track-2) (car track-1)))
          ((car track-2)
           ((cdr track-1) (car track-2)))
          (else
            (let ((node (gensym "N")))
              ((cdr track-1) node)
              ((cdr track-2) node))))))

(define (parse-railway ast)
  (set! tracks (make-hash))
  (set! switches (make-hash))
  (let loop ((data (cddr ast)) (done-defining? #f))
    (unless (null? data)
      (let ((datum (car data)))
        (case (car datum)
          ((define)
           (case (cadr datum)
             ((SEGMENTS) (void))
             ((SWITCHES) (void))
             ((DETECTION-BLOCKS)
              (let ((ids (cdaddr datum)))
                (for-each (lambda (db-id)
                            (set-track-db?! (hash-ref tracks db-id) #t))
                          ids)))
             (else
               (unless done-defining?
                 (let ((type (cadr (caddr datum)))
                       (id (cadr datum))
                       (piko-track (eval (caddr (cdaddr datum)))))
                   (if (eq? type 'block%)
                     (gentrack piko-track id)
                     (piko-track id))))))
           (loop (cdr data) done-defining?))
          ((connect)
           (eval-connect (cdr datum))
           (loop (cdr data) #t)))))))

(define (print-tracks)
  (define (get-or-gen-node node)
    (if node node (gensym "N")))
  (hash-for-each
    tracks
    (lambda (id track)
      (printf "~a ~a ~a ~a ~a~%"
              (if (track-db? track) 'D 'T)
              id
              (get-or-gen-node (track-start track))
              (get-or-gen-node (track-end track))
              (track-length track)))))

(define (print-switches)
  (define printed (mutable-set))
  (define (printed? switch)
    (set-member? printed switch))
  (define (print-switch switch)
    (define (get-id switch-or-track)
      (if (track? switch-or-track)
        (track-id switch-or-track)
        (switch-id switch-or-track)))
    (set-add! printed switch)
    (hash-remove! switches (switch-id switch))
    (printf "S ~a ~a ~a~%"
            (switch-id switch)
            (get-id (switch-track-1 switch))
            (get-id (switch-track-2 switch))))
  (hash-for-each
    switches
    (lambda (id switch)
      (when (and (switch? (switch-track-1 switch))
                 (not (printed? (switch-track-1 switch))))
        (print-switch (switch-track-1 switch)))
      (when (and (switch? (switch-track-2 switch))
                 (not (printed? (switch-track-2 switch))))
        (print-switch (switch-track-2 switch)))
      (print-switch switch))))

(parse-railway (read))
(print-tracks)
(print-switches)

